package hr.fer.zemris.java.hw07.shell.commands;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import hr.fer.zemris.java.hw07.shell.Environment;
import hr.fer.zemris.java.hw07.shell.ShellCommand;
import hr.fer.zemris.java.hw07.shell.ShellStatus;
import hr.fer.zemris.java.hw07.shell.namebuilder.*;

/**
 * Function ,using a regex expression ,finds all required files form source folder,and 
 * than, using a mask expression, generates new names for that files, which will 
 * then be moved in a destination folder under that new names.
 * @author Mateo
 *
 */
public class Massrename implements ShellCommand {

	
	/**
	 * Function reads destionation and source folder from arguments ,
	 * then goes file by file in the source folder and decides 
	 * if that name matches given regex (3rd arugment). If does,
	 * it is then  moved to dest.folder under a new name that 
	 * is generated by a rule from 4th argument.
	 */
	@Override
	public ShellStatus executeCommand(Environment env, String arguments) {

		arguments = arguments.trim();

		String[] args = arguments.split("\\s+");

		if (args.length < 4) {
			env.writeln("Too few arguments");
			return ShellStatus.CONTINUE;
		}

		File f = new File(args[0]);

		NameBuilderParser parser = new NameBuilderParser(args[4]);
		NameBuilder builder = parser.getNameBuilder();
		Pattern pattern = Pattern.compile(args[3], Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

		for (File i : f.listFiles()) {
			Matcher matcher = pattern.matcher(i.getName());
			if (!i.getName().matches(pattern.pattern()))
				continue;

			
			NameBuilderInfo info = makeInfo(matcher.reset());
			builder.execute(info);
			String newName = info.getStringBuilder().toString();
	
			switch (args[2]) {
			case "filter":
				
				System.out.println(i.getName());
				break;
				
			case "groups":
				
				env.write(i.getName());
				matcher.reset();
				if(matcher.find()) {
					
					for(int t=0;t<= matcher.groupCount();t++) {
						env.write(" "+ t + ": "+ matcher.group(t));
					}
				}
				env.writeln("");
				continue;
				
			case "show":
	
				env.writeln(i.getName() + " => "+ newName);
				continue;
				
			case "execute":

				try {
					Files.move(i.toPath(), Paths.get(args[1]).resolve(newName),  StandardCopyOption.REPLACE_EXISTING);
				} catch (IOException e) {
					e.printStackTrace();
				}
				env.writeln(i.getName() + " => "+ newName);
				continue;
				
			default:
				env.writeln("Unsupported sub-command");
			}
		}
		return ShellStatus.CONTINUE;
	}

	/**
	 * Function creates a NameBuilderInfo object using a matcher object,which is
	 * specific to each file.
	 * @param matcher matcher name of the current file and a regex expression
	 * @return returns a NameBuuilderInfo object
	 */
	private NameBuilderInfo makeInfo(Matcher matcher) {
		return new NameBuilderInfo() {
			StringBuilder str = new StringBuilder();
			boolean test = matcher.find();
			Matcher m = matcher;

			@Override
			public StringBuilder getStringBuilder() {

				return str;
			}

			@Override
			public String getGroup(int index) {

				if (test) {
					return m.group(index);

				} else {
					throw new IllegalArgumentException("NBI error");
				}
			}

		};

	}
	/**
	 * Funtion returns command name as a string.
	 * @return command name
	 */
	@Override
	public String getCommandName() {
		
		return "massrename";
	}
	/**
	 * Function returns a list which holds a description abouut current command.
	 * @return returns a list which holds the description
	 */
	@Override
	public List<String> getCommandDescription() {
		
		List<String> desc = new LinkedList<>();
		desc.add("Command moves selected files from source to destination folder. ");
		desc.add("Selection is done by regex expression. ");
		desc.add("4th argument is a rule by which new filenames are generated. ");
		return desc;
	}
	
	

}
